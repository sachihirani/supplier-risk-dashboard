# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ivmtu2UhKD3bm_qMf0O8S4hBVD41kRtB
"""

import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime
from PIL import Image

# --- Config ---
st.set_page_config(page_title="Agri Cross Invoice Risk Dashboard", layout="wide")
logo = Image.open("logo.png")
st.sidebar.image(logo, use_container_width=True)

# --- Load & clean ---
df = pd.read_csv("final_supplier_risk.csv", parse_dates=["Invoice_Date", "Due_Date", "Payment_Date"])
df["Status"] = df["Status"].astype(str).str.strip().str.title()
df["Payment_Status"] = df["Payment_Status"].astype(str).str.strip().str.title()

# ---------- Clear Filters Logic ----------
filter_keys = ["supplier_type", "service_cat", "invoice_date_range", "supplier_name"]

if "clear_triggered" not in st.session_state:
    st.session_state.clear_triggered = False

if st.session_state.clear_triggered:
    for key in filter_keys:
        if key in st.session_state:
            del st.session_state[key]
    st.session_state.clear_triggered = False


# ---------- SIDEBAR FILTERS ----------
st.sidebar.header("Filters")

supplier_type = st.sidebar.multiselect(
    "Supplier Type",
    sorted(df["Supplier_Type"].dropna().unique()),
    key="supplier_type"
)

service_cat = st.sidebar.multiselect(
    "Service Category",
    sorted(filtered_df["Service_Category"].dropna().unique()),
    key="service_cat"
)

supplier_name = st.sidebar.multiselect(
    "Supplier Name",
    sorted(filtered_df["Name"].dropna().unique()),
    key="supplier_name"
)

invoice_date_range = st.sidebar.date_input(
    "Invoice Date Range",
    value=(df["Invoice_Date"].min(), df["Invoice_Date"].max()),
    min_value=df["Invoice_Date"].min(),
    max_value=df["Invoice_Date"].max(),
    key="invoice_date_range"
)


if st.sidebar.button("Clear All Filters"):
    st.session_state.clear_triggered = True




# ---------- APPLY FILTERS ----------
df_filtered = df.copy()

if supplier_type:
    df_filtered = df_filtered[df_filtered["Supplier_Type"].isin(supplier_type)]
if service_cat:
    df_filtered = df_filtered[df_filtered["Service_Category"].isin(service_cat)]
if supplier_name:
    df_filtered = df_filtered[df_filtered["Name"].isin(supplier_name)]
if isinstance(invoice_date_range, tuple) and len(invoice_date_range) == 2:
    start_date, end_date = invoice_date_range
    df_filtered = df_filtered[
        (df_filtered["Invoice_Date"] >= pd.to_datetime(start_date)) &
        (df_filtered["Invoice_Date"] <= pd.to_datetime(end_date))
    ]


# --- Tabs ---
tab1, tab2, tab3 = st.tabs(["Key Insights", "Risk Overview", "To Pay Hub"])

# ---------------- Tab 1: Key Insights ----------------
with tab1:
    st.title("Agri Cross Invoice Risk Dashboard")
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Total Invoices", len(df_filtered))
    col2.metric("Total Invoice Amount", f"${df_filtered['Invoice_Amount'].sum():,.0f}")
    col3.metric("Paid On Time", df_filtered[df_filtered["Status"] == "On Time"].shape[0])
    col4.metric("Paid Late", df_filtered[df_filtered["Status"] == "Late"].shape[0])

    st.subheader("Invoice Amount Over Time")
    monthly = df_filtered.copy()
    monthly["Month"] = monthly["Invoice_Date"].dt.to_period("M").astype(str)
    monthly_sum = monthly.groupby("Month")["Invoice_Amount"].sum().reset_index()
    st.plotly_chart(px.line(monthly_sum, x="Month", y="Invoice_Amount", title="Monthly Invoice Totals"), use_container_width=True)

    st.subheader("Invoice Status Distribution")
    status_counts = df_filtered["Status"].value_counts().reset_index()
    status_counts.columns = ["Status", "Count"]
    st.plotly_chart(px.pie(status_counts, names="Status", values="Count", hole=0.5), use_container_width=True)

    st.subheader("Top 10 Suppliers by Amount")
    top_amt = df_filtered.groupby(["Supplier_ID", "Name"])["Invoice_Amount"].sum().nlargest(10).reset_index()
    st.dataframe(top_amt)

    st.subheader("Top 10 Suppliers by Frequency")
    top_freq = df_filtered.groupby(["Supplier_ID", "Name"]).size().nlargest(10).reset_index(name="Invoice Count")
    st.dataframe(top_freq)

# ---------------- Tab 2: Risk Overview ----------------
with tab2:
    st.header("Risk Overview")

    # ---- Risk Score Bar Chart (Excluding 0) ----
    if "Risk_Score" in df_filtered.columns and not df_filtered["Risk_Score"].dropna().empty:
        filtered_risks = df_filtered[df_filtered["Risk_Score"].isin([1, 2, 3])]
        risk_counts = filtered_risks["Risk_Score"].value_counts().sort_index().reset_index()
        risk_counts.columns = ["Risk Score", "Count"]

        colour_map = {
            1: "#FFD700",  # Yellow
            2: "#FFA500",  # Orange
            3: "#FF4500"   # Red
        }
        risk_counts["Colour"] = risk_counts["Risk Score"].map(colour_map)

        fig = px.bar(
            risk_counts,
            x="Count",
            y="Risk Score",
            orientation="h",
            title="Invoices by Risk Score (1â€“3 Only)",
            color="Risk Score",
            color_discrete_map=colour_map,
            log_x=True
        )
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.warning("No risk score data available to display.")

    # ---- Risk KPI Cards ----
    col7, col8, col9 = st.columns(3)
    col7.metric("Duplicate ABNs", int(df_filtered["Duplicate_ABN"].sum()))
    col8.metric("Duplicate Invoices", int(df_filtered["Duplicate_Invoice"].sum()))
    col9.metric("High Amount Invoices > 30k", int(df_filtered["High_Amount"].sum()))

    # ---- Risk Score Filtered Invoice Table ----
    st.subheader("Invoices by Risk Level")

    display_risk_labels = {
        1: "ðŸŸ¨ Low Risk (Score 1)",
        2: "ðŸŸ§ Medium Risk (Score 2)",
        3: "ðŸŸ¥ High Risk (Score 3)"
    }
    reverse_risk_lookup = {v: k for k, v in display_risk_labels.items()}

    selected_risk_label = st.radio(
        "Select Risk Category",
        [display_risk_labels[k] for k in [1, 2, 3]],
        horizontal=True
    )

    selected_risk_score = reverse_risk_lookup[selected_risk_label]
    risk_filtered_df = df_filtered[df_filtered["Risk_Score"] == selected_risk_score]

    st.dataframe(
        risk_filtered_df[["Invoice_ID", "Name", "Invoice_Amount", "Due_Date", "Risk_Score"]],
        use_container_width=True
    )



# ---------------- Tab 3: To Pay Hub ----------------
with tab3:
    st.header("To Pay Hub")

    from datetime import datetime

    # Dynamically create derived status using flags
    unpaid_df = df_filtered.copy()
    unpaid_df["Payment_Status_Derived"] = "Other"
    unpaid_df.loc[unpaid_df["Unpaid_Flag"] == 1, "Payment_Status_Derived"] = "Unpaid"
    unpaid_df.loc[unpaid_df["Unpaid_HighPriority_Flag"] == 1, "Payment_Status_Derived"] = "Unpaid_HighPriority"
    unpaid_df.loc[unpaid_df["Unpaid_LatePayNow_Flag"] == 1, "Payment_Status_Derived"] = "Unpaid_LatePayNow"
    unpaid_df.loc[unpaid_df["Unpaid_TodayPayNow_Flag"] == 1, "Payment_Status_Derived"] = "Unpaid_TodayPayNow"
    unpaid_df.loc[unpaid_df["Unpaid_Priority_Flag"] == 1, "Payment_Status_Derived"] = "Unpaid_Priority"

    # Keep only these
    unpaid_statuses = [
        "Unpaid_LatePayNow",
        "Unpaid_TodayPayNow",
        "Unpaid_HighPriority",
        "Unpaid_Priority",
        "Unpaid"
    ]
    unpaid_df = unpaid_df[unpaid_df["Payment_Status_Derived"].isin(unpaid_statuses)]

    # Donut Chart
    st.subheader(f"Unpaid Invoice Categories as of {datetime.today().strftime('%d %b %Y')}")
    unpaid_summary = unpaid_df["Payment_Status_Derived"].value_counts().reset_index()
    unpaid_summary.columns = ["Unpaid Status", "Count"]

    if not unpaid_summary.empty:
        st.plotly_chart(
            px.pie(unpaid_summary, names="Unpaid Status", values="Count", hole=0.4),
            use_container_width=True
        )
    else:
        st.warning("No unpaid invoice categories found.")

    # Display name mapping
    display_labels = {
        "Unpaid_LatePayNow": "ðŸ”´ Overdue",
        "Unpaid_TodayPayNow": "ðŸ”µ Due Today",
        "Unpaid_HighPriority": "ðŸŸ  Due in 2 Days",
        "Unpaid_Priority": "ðŸŸ¡ Due in 1 Week",
        "Unpaid": "ðŸŸ¢ Due Soon"
    }
    reverse_lookup = {v: k for k, v in display_labels.items()}

    st.subheader("Unpaid Invoice Table")
    selected_label = st.radio(
        "Select Category",
        [display_labels[k] for k in unpaid_statuses],
        horizontal=True
    )

    selected_unpaid_type = reverse_lookup[selected_label]
    filtered_table = unpaid_df[unpaid_df["Payment_Status_Derived"] == selected_unpaid_type]
    st.dataframe(filtered_table[["Invoice_ID", "Name", "Due_Date", "Invoice_Amount", "Payment_Status_Derived"]], use_container_width=True)